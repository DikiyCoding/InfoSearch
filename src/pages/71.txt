Неудачные приёмы работы с NGRX / Блог компании RUVDS.com / Хабр Все сервисы Хабра 2 937,32 Рейтинг VDS/VPS-хостинг. Скидка 10% по коду HABR вчера в 16:17 Неудачные приёмы работы с NGRX , , Перевод В моих предыдущих материалах я () об анти-паттернах Angular и о рекомендованных приёмах работы с . После того, как я полгода проработал с NGRX и как следует разобрался с этой библиотекой, полагаю, что пришло время рассказать о некоторых приёмах работы, которые я (часто это относится ко всему сообществу тех, кто пользуется NGRX) нахожу вредными или слишком сложными. Никогда (почти никогда) не подписывайтесь на Store: используйте селекторы Взгляните на этот код: Как по мне, так это — просто ужас. Во-первых, подписка на хранилище означает, что позже нам надо будет от него отписаться (в данном примере это не реализовано), а это значит, что перед нами встанут дополнительные трудности. Во-вторых — это значит, что в компоненте будет присутствовать некий объём императивного кода. И наконец (хотя это — далеко не последний недостаток показанного здесь кода), тут возможности NGRX используются не в полном объёме. Попробуем улучшить код: Этот вариант, конечно, лучше предыдущего. Нем теперь не только не надо отписываться от хранилища (асинхронный конвейер сделает всё сам), но и можно без проблем воспользоваться ради улучшения производительности. Есть тут и ещё один плюс — нам удалось снизить объём кода и сделать его более декларативным. Вот ещё пример: Здесь мы проверяем состояние на предмет наличия в нём определённого значения и, обнаружив это значение, выполняем некое действие. С таким сценарием можно столкнуться в любом приложении, но неправильно реализовывать подобный функционал именно так. Потребители производного состояния не должны реагировать на изменение состояния, прибегая к действиям. Для этих целей у нас имеется класс : } В компоненте при этом вообще нет кода. Помните о том, что изменять состояние должны лишь действия. Реагировать на действия следует с помощью эффектов и редьюсеров, а не работая с производным состоянием. В заголовке этого раздела есть фраза «почти никогда», поэтому, очевидно, существуют ситуации, в которых подписка на имеет смысл. Представьте себе следующее: в нашем приложении имеется сложная система разрешений, регулируемых администратором, который может менять их в режиме реального времени. Эти разрешения, конечно, хранятся в . Теперь представьте себе, что мы, в компоненте, пользуемся реактивными формами, при этом некоторые поля таких форм могут отключиться в процессе работы с формой, если администратор изменит разрешения пользователя в тот момент, когда он заполняет форму. Состояние при этом будет обновляться в режиме реального времени. Как отключить поле ввода, основываясь на разрешениях, сведения о которых находятся в хранилище? Дело тут в том, что отключить реактивный элемент можно только используя его метод . Это, по своей природе, императивная операция, у которой нет декларативной альтернативы (при условии, что нам совершенно необходимо использовать реактивные формы). В данном случае, так как значение, отвечающее за отключение элемента управления, зависит от значения из нашего , мы вынуждены подписаться на хранилище. Это приводит нас к следующему практическому правилу: Никогда не подписывайтесь на Store вручную, за исключением тех случаев, когда необходимо выполнить императивную стороннюю функцию (вроде FormControl.disable()), и при этом у вас нет другой возможности добиться желаемого. Если же вы так и поступили — не забудьте отписаться! Ещё один хороший и сравнительно новый способ решения подобных задач без оформления подписки заключается в использовании хранилища с поддерживаемыми им . Не пользуйтесь методом pipe() наблюдаемых объектов, выбранных из хранилища Мы отказались от подписок на хранилище или на наблюдаемые объекты производного состояния. Поэтому теперь, по идее, всё должно быть совершенно замечательно. Но, на самом деле, не всё так просто. Взгляните на следующий код: В этом примере исходное состояние хранится в , в объекте , но в данном компоненте нам, на самом деле, нужен лишь список активных пользователей. Поэтому мы просто преобразуем наблюдаемый объект производного состояния с использованием операторов и чистых функций. А это, вероятно, не так уж и плохо. Но дело тут в том, что даже самые простые RxJS-операторы устроены сложнее, чем простые функции-селекторы. В результате в коде появляется больше «информационного шума», а если речь идёт о сложной логике, то усложняется и отладка кода. Решим эту проблему, воспользовавшись именованным селектором: А после этого мы можем немедленно воспользоваться получившимся производным состоянием: В результате мы выходим на более компактный код, который легче читать. Глядя на этот код можно сразу же разобраться в том, что именно было выбрано, поэтому он отличается и большей декларативностью. Хорошей альтернативой этому неудачному приёму работы является использование NGRX-селекторов: Не пользуйтесь pipe() и операторами для работы с производным состоянием. Вместо этого применяйте именованные селекторы. Не пользуйтесь функцией combineLatest(). Вместо этого применяйте именованные селекторы Иногда состояния приложений бывают очень сложными, они могут зависеть от нескольких сущностей. Иногда в основе производного состояния лежит не одно исходное состояние, а комбинация из двух или большего количества таких состояний. Вот пример. Представим, что у нас есть набор объектов, описывающих товары в магазине одежды. Это — объекты типа , хранящиеся в массиве. В проекте имеется корзина покупателя, в основе которой тоже лежит массив объектов . Добавлять в корзину товары (объекты ) можно, пользуясь кнопкой «Добавить в корзину», но если соответствующий объект уже присутствует в корзине, нам надо показать пользователю другую кнопку, на которой написано «Убрать из корзины». Логика работы с корзиной не слишком сложна, нам, для её реализации, нужно лишь добавить к каждому объекту из производного списка элементов свойство . Его значение указывает на то, имеется ли в массиве корзины элемент с соответствующим . У нас есть два селектора, которые позволяют выбирать все элементы и массив, представляющий корзину. Вот код компонента: Сейчас вполне очевидно то, что эта логика выглядит немного сложнее, чем логика, которую стоило бы размещать в классе компонента. Кроме того, опять же, хотя логика эта и декларативна, для того чтобы разобраться в том, что тут происходит, нужно внимательно прочесть код и как следует его понять. Что делать в такой ситуации? Ответ, снова, заключается в применении селекторов. NGRX позволяет комбинировать селекторы с использованием : Теперь код, благодаря наличию в нём новых функций, получился гораздо понятнее. Сначала мы выбираем все элементы и то, что находится в корзине. Затем создаём ещё один селектор, который выбирает лишь идентификаторы элементов, находящихся в корзине (селекторы ). И, наконец, мы комбинируем два селектора для того чтобы преобразовать список всех элементов. В данном конкретном компоненте мы используем лишь результирующий селектор. Тут у вас может появиться вопрос о том, почему мы создали четыре селектора. Дело тут в том, что лучше иметь много простых селекторов, чем меньшее количество селекторов более сложных. Это упрощает многократное использование кода и создание нового кода путём компоновки того, который уже имеется в проекте. Отсюда выводим следующее правило: Если вы замечаете, что combineLatest() используется в сочетании с производным состоянием — подумайте о комбинировании селекторов с применением createSelector(). Постарайтесь избегать модификации вложенного состояния с использованием withLatestFrom Иногда выполнение эффектов требует, чтобы мы приняли бы во внимание ещё какое-то состояние, уже имеющееся в хранилище. Например — представьте, что у нас есть таблица, которую можно фильтровать и сортировать с использованием каких-то кнопок. Имеется действие , которое принимает объект, задающий порядок сортировки ), и добавляет его к объекту , который содержит все сведения о соответствующем запросе (фильтрация, разбиение результатов на страницы, сортировка — для выполнения каждой из этих операций имеется собственное действие). Потом отправляет получившийся объект на сервер, пользуясь соответствующей службой. При этом сервер принимает лишь полностью оформленные запросы (содержащие сведения о сортировке, о фильтрации и о разбиении таблицы на страницы), а не отдельные элементы запросов, но действие выполняет лишь модификацию той части запроса, которая имеет отношение к сортировке (модифицирует вложенное состояние). И в компоненте, из которого мы отправляем действие , может и не быть полного запроса. Всё это может склонить нас к написанию следующего кода в эффекте: Тут мы, в отчаянной попытке избежать выполнения неких действий в компоненте, сделали много нехорошего. Для начала — обратите внимание на то, как мы работаем с тремя действиями, которые отправляют один и тот же запрос (одно — для сортировки, одно — для фильтрации, одно — для разбиения таблицы на страницы). Мы, кроме того, принимаем уже существующее состояние, пользуясь . Что теперь с этим всем делать? Начнём с избавления от трёх отдельных действий (, и ). Прислушаемся к Майку Райану, который в видео говорит о том, что очень важно, чтобы код действий был бы чистым и компактным. Теперь у нас имеется лишь одно действие, , которое принимает весь объект запроса. А в компоненте мы сделаем следующее: Обратите внимание на то, что код компонента не потерял простоты и компактности. Каждый его метод отвечает за поддержку отдельного сценария, отправляя при этом одно и то же действие. А из-за того, что тут используется одно и то же действие, мы теперь можем переработать и наш эффект, приведя его к такому виду: Теперь мы работаем лишь с одним действием, решаем одну простую задачу, и при этом мы избавились от . Наличие withLatestFrom в коде эффекта может говорить о невысоком качестве кода, что указывает на то, что некоторые механизмы программы, вероятно, можно реализовать проще. Никогда не размещайте в хранилище производное состояние Один из важных аспектов работы с NGRX (и, если уж на то пошло, с любой системой управления состоянием приложений) заключается в проведении различия между исходным и производным состоянием. Исходное состояние — это то, что хранится в . Например — это данные, полученные от бэкенда приложения, которые тут же помещены в хранилище. А производное состояние — это такое состояние, которое получено на основе каких-то трансформаций исходного состояния, обычно выполняемых с помощью селекторов. Например, список элементов из примера о комбинировании селекторов — это яркий пример производного состояния. Иногда разработчики склонны записывать производное состояние в то же хранилище, где находится исходное состояние. Это, по разным причинам, неудачная идея: В хранилище находится больше данных, чем, на самом деле, нужно. Возникает необходимость в синхронизации двух частей состояния. Если, например, какое-то действие меняет исходное состояние, нужно модифицировать и производное состояние. Объект выглядит весьма неопрятно. Взгляните на этот пример: Тут совместно хранятся и исходное состояние (список всей одежды), и производное состояние (отфильтрованный список). Не лучше ли было бы хранить запрос и получать отфильтрованный список одежды, пользуясь селектором, комбинирующим этот запрос и весь список? Вот как это может выглядеть: А после этого в компоненте можно просто воспользоваться селектором производного состояния. Итоги Возможно, вы обратили внимание на то, что при решении многих проблем, связанных с неудачными приёмами работы в NGRX, применяются селекторы. Дело тут в том, что основная задача, которая стоит перед системами управления состоянием приложений заключается в различении производного и исходного состояний. Когда разработчику удаётся удачно разделить эти сущности и создать чёткие механизмы по работе с ними, по выбору из них того, что ему нужно, это означает, что такой разработчик получит простое, декларативное и реактивное Angular-приложение, в основе которого лежит NGRX. Пользуетесь ли вы NGRX в своих проектах? Теги: Добавить метки Хабы: Укажите причину минуса, чтобы автор поработал над ошибками Отправить анонимно Пометьте публикацию своими метками Метки лучше разделять запятой. Например: программирование, алгоритмы Сохранить +14 17 909 Поделиться Скопировать ссылку Нарушение Опишите суть нарушения Отправить VDS/VPS-хостинг. Скидка 10% по коду HABR Пользователь Платежная система Похожие публикации 6 апреля 2021 в 11:47 24 2,5k 19 22 марта 2021 в 12:07 23 24,2k 293 12 декабря 2017 в 14:08 12 50,4k 152 Комментарии 4 вчера в 17:35 0 В первую очередь, я бы хотел отметить, что метод select инстанса store, лучше не использовать, он оставлен там исключительно для совместимости. Если вы зайдете в исходный код store.ts, то увидите что метода select биндит функцию-оператор: которая импортируется из @ngrx/core, а сам класс Store наследуется от Observable, и соответственно при инжекте в ваш компонент это нечто иное как стрим. По этому рекомендуется использовать в таком ключе: Второе, что я хотел бы сказать это то, что все манипуляции со стором, лучше хранить в отдельных сервисах, что бы не плодить кучу зависимостей store, select, dispatch и ваш компонент не превращался в простыни ненужных логик по срезу данных, их получению, экшенов, фильтрации и много другое. Выносите это к примеру в сервис модуля, table.store.service, и в нем описываете методы: и дальше этот сервис инжектите в ваших компонентах… вчера в 19:40 0 Вопрос, если прятать стор за сервисом, то зачем нужен NGRX? Ведь проще сделать `BehaviourObservable` и просто менять Value этого Observable. вчера в 21:07 0 если вы прячите детали работы стора для компонента за сервис, это никак не заменяет NGRX на BehaverSubject ;) вчера в 22:50 0 Чтобы не путать сервисы, скрывающие стор от компонента, с сервисами, которые про работу с бекендом, называю их фасадами (facade). Там же можно часть императивной логики, если нужно, разместить. А про select — не знал, спасибо. Только могут оставлять комментарии. , пожалуйста. Информация Дата основания 27 июля 2015 г. Локация Москва Россия Сайт Численность 11–30 человек Дата регистрации 18 марта 2016 г. Представитель Ссылки ruvds.com ruvds.com ruvds.com ruvds.com ruvds.com ruvds.com ruvds.com ruvds.com ruvds.com ruvds.com Приложения RUVDS Client Приложение для мониторинга и управления виртуальными серверами RUVDS с мобильных устройств. Виджет Виджет Блог на Хабре 909 5,4k 1,6k 5,6k 4,1k 14,3k 2,5k 3,4k 18,4k 4,2k 5,2k 3k 11k 5,2k 4,8k 4,8k 2,7k 11,8k 11,6k 5,5k Самое читаемое +49 17,5k 53 +111 71k 65 +52 14,4k 58 +20 14,2k 2 Мегапост +218 104k 83 +111 71k 65 +45 66,6k 144 +62 36,6k 58 Подборка +231 252k 446 +56 213k 112 +592 209k 505 +62 174k 111 Мегапост Ваш аккаунт Разделы Информация Услуги © 2006 – 2021 «» Настройка языка Интерфейс Русский English Язык публикаций Русский Английский Сохранить настройки